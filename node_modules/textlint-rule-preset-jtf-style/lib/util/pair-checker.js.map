{"version":3,"sources":["../../src/util/pair-checker.js"],"names":["flat","array","concat","apply","checkPair","context","left","right","Syntax","RuleError","report","getSource","helper","RuleHelper","isInParagraph","currentStrInParagraph","findAllSymbolLocations","symbol","text","index","symbolLocations","length","indexOf","push","foundMissingPairNodes","matchParentheses","map","node","leftSymbolLocations","rightSymbolLocations","allSymbolLocations","sort","a","b","loc","isCompletedParentheses","lastUnmatchParences","item","shift","last","pop","Paragraph","isChildNode","BlockQuote","Str","missingPairList","forEach","message"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AACA;;AACA;;;;;;;;;;AACA,IAAMA,IAAI,GAAIC,KAAD,IAAW;AACpB,SAAO,GAAGC,MAAH,CAAUC,KAAV,CAAgB,EAAhB,EAAoBF,KAApB,CAAP;AACH,CAFD;;AAGO,SAASG,SAAT,CAAmBC,OAAnB,QAA6C;AAAA,MAAjB;AAAEC,IAAAA,IAAF;AAAQC,IAAAA;AAAR,GAAiB;AAChD,uBAAOD,IAAP;AACA,uBAAOC,KAAP;AACA,MAAM;AAAEC,IAAAA,MAAF;AAAUC,IAAAA,SAAV;AAAqBC,IAAAA,MAArB;AAA6BC,IAAAA;AAA7B,MAA2CN,OAAjD;AACA,MAAMO,MAAM,GAAG,IAAIC,8BAAJ,CAAeR,OAAf,CAAf;AACA,MAAIS,aAAa,GAAG,KAApB;AACA,MAAIC,qBAAqB,GAAG,EAA5B;AACA;AACJ;AACA;AACA;AACA;;AACI,MAAMC,sBAAsB,GAAG,CAACC,MAAD,EAASC,IAAT,KAAkB;AAC7C,QAAIC,KAAK,GAAG,CAAZ;AACA,QAAMC,eAAe,GAAG,EAAxB;;AACA,WAAOD,KAAK,GAAGD,IAAI,CAACG,MAApB,EAA4B;AACxBF,MAAAA,KAAK,GAAGD,IAAI,CAACI,OAAL,CAAaL,MAAb,EAAqBE,KAArB,CAAR;AACA,UAAIA,KAAK,GAAG,CAAZ,EAAe;AACfC,MAAAA,eAAe,CAACG,IAAhB,CAAqB;AACjBJ,QAAAA,KADiB;AAEjBF,QAAAA;AAFiB,OAArB;AAIAE,MAAAA,KAAK,IAAI,CAAT;AACH;;AACD,WAAOC,eAAP;AACH,GAbD;;AAcA,MAAMI,qBAAqB,GAAIT,qBAAD,IAA2B;AACrD,QAAMU,gBAAgB,GAAGzB,IAAI,CACzBe,qBAAqB,CAACW,GAAtB,CAA2BC,IAAD,IAAU;AAChC,UAAIT,IAAI,GAAGP,SAAS,CAACgB,IAAD,CAApB;AACA,UAAMC,mBAAmB,GAAGZ,sBAAsB,CAACV,IAAD,EAAOY,IAAP,CAAlD;AACA,UAAMW,oBAAoB,GAAGvB,IAAI,KAAKC,KAAT,GAAiBS,sBAAsB,CAACT,KAAD,EAAQW,IAAR,CAAvC,GAAuD,EAApF;AACA,UAAMY,kBAAkB,GAAG,CAAC,GAAGF,mBAAJ,EAAyB,GAAGC,oBAA5B,EAAkDE,IAAlD,CACvB,CAACC,CAAD,EAAIC,CAAJ,KAAUD,CAAC,CAACb,KAAF,GAAUc,CAAC,CAACd,KADC,CAA3B;AAGA,aAAOW,kBAAkB,CAACJ,GAAnB,CAAwBQ,GAAD,oCAAeA,GAAf;AAAoBP,QAAAA;AAApB,QAAvB,CAAP;AACH,KARD,CADyB,CAA7B;;AAWA,QAAIrB,IAAI,KAAKC,KAAb,EAAoB;AAChB,UAAM4B,sBAAsB,GAAGV,gBAAgB,CAACJ,MAAjB,GAA0B,CAA1B,IAA+B,CAA9D;;AACA,UAAIc,sBAAJ,EAA4B;AACxB,eAAO,EAAP;AACH,OAFD,MAEO;AACH,eAAO,CAACV,gBAAgB,CAACA,gBAAgB,CAACJ,MAAjB,GAA0B,CAA3B,CAAjB,CAAP;AACH;AACJ,KAPD,MAOO;AACH,UAAMe,mBAAmB,GAAG,EAA5B;;AACA,aAAOX,gBAAgB,CAACJ,MAAjB,GAA0B,CAAjC,EAAoC;AAChC,YAAMgB,IAAI,GAAGZ,gBAAgB,CAACa,KAAjB,EAAb;;AACA,YAAID,IAAI,CAACpB,MAAL,IAAeX,IAAnB,EAAyB;AACrB8B,UAAAA,mBAAmB,CAACb,IAApB,CAAyBc,IAAzB;AACH,SAFD,MAEO;AACH;AACA,cAAME,IAAI,GAAGH,mBAAmB,CAACI,GAApB,EAAb;;AACA,cAAID,IAAJ,EAAU;AACN,gBAAIA,IAAI,CAACtB,MAAL,IAAeV,KAAnB,EAA0B;AACtB6B,cAAAA,mBAAmB,CAACb,IAApB,CAAyBgB,IAAzB;AACAH,cAAAA,mBAAmB,CAACb,IAApB,CAAyBc,IAAzB;AACH;AACJ,WALD,MAKO;AACHD,YAAAA,mBAAmB,CAACb,IAApB,CAAyBc,IAAzB;AACH;AACJ;AACJ;;AACD,aAAOD,mBAAP;AACH;AACJ,GAxCD;;AAyCA,SAAO;AACH,KAAC5B,MAAM,CAACiC,SAAR,EAAmBd,IAAnB,EAAyB;AACrB,UAAIf,MAAM,CAAC8B,WAAP,CAAmBf,IAAnB,EAAyB,CAACnB,MAAM,CAACmC,UAAR,CAAzB,CAAJ,EAAmD;AAC/C;AACH;;AACD5B,MAAAA,qBAAqB,GAAG,EAAxB;AACAD,MAAAA,aAAa,GAAG,IAAhB;AACH,KAPE;;AAQH,KAACN,MAAM,CAACoC,GAAR,EAAajB,IAAb,EAAmB;AACf,UAAI,CAACb,aAAL,EAAoB;AAChB;AACH;;AACDC,MAAAA,qBAAqB,CAACQ,IAAtB,CAA2BI,IAA3B;AACH,KAbE;;AAcH,eAAInB,MAAM,CAACiC,SAAX,cAA+B;AAC3B,UAAMI,eAAe,GAAGrB,qBAAqB,CAACT,qBAAD,CAA7C,CAD2B,CAE3B;;AACAD,MAAAA,aAAa,GAAG,KAAhB,CAH2B,CAI3B;;AACA,UAAI+B,eAAe,CAACxB,MAAhB,KAA2B,CAA/B,EAAkC;AAC9B;AACH;;AACDwB,MAAAA,eAAe,CAACC,OAAhB,CAAwB,SAA6B;AAAA,YAA5B;AAAE3B,UAAAA,KAAF;AAASQ,UAAAA,IAAT;AAAeV,UAAAA;AAAf,SAA4B;AACjD,YAAI8B,OAAO,GACP9B,MAAM,KAAKX,IAAX,aACSA,IADT,2CACqBC,KADrB,mEACsCD,IADtC,SAC6CC,KAD7C,cAESA,KAFT,2CAEsBD,IAFtB,mEAEsCA,IAFtC,SAE6CC,KAF7C,CADJ;AAIAG,QAAAA,MAAM,CAACiB,IAAD,EAAO,IAAIlB,SAAJ,CAAcsC,OAAd,EAAuB;AAAE5B,UAAAA;AAAF,SAAvB,CAAP,CAAN;AACH,OAND;AAOH;;AA7BE,GAAP;AA+BH","sourcesContent":["// LICENSE : MIT\n\"use strict\";\n/**\n * 「と」といったペアがちゃんと閉じられているかをチェックします\n * @param {object} context\n * @param {string} left\n * @param {string} right\n * @returns {object}\n */\nimport assert from \"assert\";\nimport { RuleHelper } from \"textlint-rule-helper\";\nconst flat = (array) => {\n    return [].concat.apply([], array);\n};\nexport function checkPair(context, { left, right }) {\n    assert(left);\n    assert(right);\n    const { Syntax, RuleError, report, getSource } = context;\n    const helper = new RuleHelper(context);\n    let isInParagraph = false;\n    let currentStrInParagraph = [];\n    /**\n     * `Str` nodeの配列を受け取り、pairが見つからないnodeを返す\n     * @param {Object} currentStrInParagraph\n     * @returns {{node, index}[]}\n     */\n    const findAllSymbolLocations = (symbol, text) => {\n        let index = 0;\n        const symbolLocations = [];\n        while (index < text.length) {\n            index = text.indexOf(symbol, index);\n            if (index < 0) break;\n            symbolLocations.push({\n                index,\n                symbol\n            });\n            index += 1;\n        }\n        return symbolLocations;\n    };\n    const foundMissingPairNodes = (currentStrInParagraph) => {\n        const matchParentheses = flat(\n            currentStrInParagraph.map((node) => {\n                let text = getSource(node);\n                const leftSymbolLocations = findAllSymbolLocations(left, text);\n                const rightSymbolLocations = left !== right ? findAllSymbolLocations(right, text) : [];\n                const allSymbolLocations = [...leftSymbolLocations, ...rightSymbolLocations].sort(\n                    (a, b) => a.index - b.index\n                );\n                return allSymbolLocations.map((loc) => ({ ...loc, node }));\n            })\n        );\n        if (left === right) {\n            const isCompletedParentheses = matchParentheses.length % 2 == 0;\n            if (isCompletedParentheses) {\n                return [];\n            } else {\n                return [matchParentheses[matchParentheses.length - 1]];\n            }\n        } else {\n            const lastUnmatchParences = [];\n            while (matchParentheses.length > 0) {\n                const item = matchParentheses.shift();\n                if (item.symbol == left) {\n                    lastUnmatchParences.push(item);\n                } else {\n                    // right\n                    const last = lastUnmatchParences.pop();\n                    if (last) {\n                        if (last.symbol == right) {\n                            lastUnmatchParences.push(last);\n                            lastUnmatchParences.push(item);\n                        }\n                    } else {\n                        lastUnmatchParences.push(item);\n                    }\n                }\n            }\n            return lastUnmatchParences;\n        }\n    };\n    return {\n        [Syntax.Paragraph](node) {\n            if (helper.isChildNode(node, [Syntax.BlockQuote])) {\n                return;\n            }\n            currentStrInParagraph = [];\n            isInParagraph = true;\n        },\n        [Syntax.Str](node) {\n            if (!isInParagraph) {\n                return;\n            }\n            currentStrInParagraph.push(node);\n        },\n        [`${Syntax.Paragraph}:exit`]() {\n            const missingPairList = foundMissingPairNodes(currentStrInParagraph);\n            // 探索おわり\n            isInParagraph = false;\n            // 全ての対が見つかったなら配列は空になる\n            if (missingPairList.length === 0) {\n                return;\n            }\n            missingPairList.forEach(({ index, node, symbol }) => {\n                let message =\n                    symbol === left\n                        ? `${left}の対となる${right}が見つかりません。${left}${right}`\n                        : `${right}の対となる${left}が見つかりません。${left}${right}`;\n                report(node, new RuleError(message, { index }));\n            });\n        }\n    };\n}\n"],"file":"pair-checker.js"}