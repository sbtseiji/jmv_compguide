"use strict";
/*
 * Copyright (c) 2020 Textlint Plugin LaTex2e team. All rights reserved.
 *
 * This file is part of textlint-plugin-latex2e.
 * This software is released under the MIT License, see LICENSE.md .
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.parse = void 0;
const latex_utensils_1 = require("latex-utensils");
const ast_node_types_1 = require("@textlint/ast-node-types");
const completeComment_1 = require("./completeComment");
const completeBlank_1 = __importDefault(require("./completeBlank"));
const paragraphize_1 = __importDefault(require("./paragraphize"));
const calculatePosition_1 = __importDefault(require("./calculatePosition"));
const pipeable_1 = require("fp-ts/lib/pipeable");
const function_1 = require("fp-ts/lib/function");
const normalize = (latexAst) => (Object.assign(Object.assign({}, latexAst), { content: latexAst.content
        .map((node) => node.kind === "env" && node.name === "document" ? node.content : [node])
        .reduce((a, b) => [...a, ...b], []) }));
const transform = (text) => (node) => {
    switch (node.kind) {
        case "command":
            switch (node.name) {
                case "textbf":
                    return [
                        {
                            loc: {
                                start: {
                                    line: node.location.start.line,
                                    column: node.location.start.column - 1,
                                },
                                end: {
                                    line: node.location.end.line,
                                    column: node.location.end.column - 1,
                                },
                            },
                            range: [node.location.start.offset, node.location.end.offset],
                            raw: text.slice(node.location.start.offset, node.location.end.offset),
                            type: ast_node_types_1.ASTNodeTypes.Strong,
                            children: node.args
                                .map(transform(text))
                                .reduce((a, b) => [...a, ...b], []),
                        },
                    ];
                case "textit":
                    return [
                        {
                            loc: {
                                start: {
                                    line: node.location.start.line,
                                    column: node.location.start.column - 1,
                                },
                                end: {
                                    line: node.location.end.line,
                                    column: node.location.end.column - 1,
                                },
                            },
                            range: [node.location.start.offset, node.location.end.offset],
                            raw: text.slice(node.location.start.offset, node.location.end.offset),
                            type: ast_node_types_1.ASTNodeTypes.Emphasis,
                            children: node.args
                                .map(transform(text))
                                .reduce((a, b) => [...a, ...b], []),
                        },
                    ];
                case "institute":
                case "title":
                case "author":
                    return [
                        {
                            loc: {
                                start: {
                                    line: node.location.start.line,
                                    column: node.location.start.column - 1,
                                },
                                end: {
                                    line: node.location.end.line,
                                    column: node.location.end.column - 1,
                                },
                            },
                            range: [node.location.start.offset, node.location.end.offset],
                            raw: text.slice(node.location.start.offset, node.location.end.offset),
                            type: ast_node_types_1.ASTNodeTypes.Header,
                            children: node.args
                                .map(transform(text))
                                .reduce((a, b) => [...a, ...b], []),
                        },
                    ];
                case "chapter":
                    return [
                        {
                            depth: 1,
                            loc: {
                                start: {
                                    line: node.location.start.line,
                                    column: node.location.start.column - 1,
                                },
                                end: {
                                    line: node.location.end.line,
                                    column: node.location.end.column - 1,
                                },
                            },
                            range: [node.location.start.offset, node.location.end.offset],
                            raw: text.slice(node.location.start.offset, node.location.end.offset),
                            type: ast_node_types_1.ASTNodeTypes.Header,
                            children: node.args
                                .map(transform(text))
                                .reduce((a, b) => [...a, ...b], []),
                        },
                    ];
                case "section":
                    return [
                        {
                            depth: 2,
                            loc: {
                                start: {
                                    line: node.location.start.line,
                                    column: node.location.start.column - 1,
                                },
                                end: {
                                    line: node.location.end.line,
                                    column: node.location.end.column - 1,
                                },
                            },
                            range: [node.location.start.offset, node.location.end.offset],
                            raw: text.slice(node.location.start.offset, node.location.end.offset),
                            type: ast_node_types_1.ASTNodeTypes.Header,
                            children: node.args
                                .map(transform(text))
                                .reduce((a, b) => [...a, ...b], []),
                        },
                    ];
                case "subsection":
                    return [
                        {
                            depth: 3,
                            loc: {
                                start: {
                                    line: node.location.start.line,
                                    column: node.location.start.column - 1,
                                },
                                end: {
                                    line: node.location.end.line,
                                    column: node.location.end.column - 1,
                                },
                            },
                            range: [node.location.start.offset, node.location.end.offset],
                            raw: text.slice(node.location.start.offset, node.location.end.offset),
                            type: ast_node_types_1.ASTNodeTypes.Header,
                            children: node.args
                                .map(transform(text))
                                .reduce((a, b) => [...a, ...b], []),
                        },
                    ];
                case "subsubsection":
                    return [
                        {
                            depth: 4,
                            loc: {
                                start: {
                                    line: node.location.start.line,
                                    column: node.location.start.column - 1,
                                },
                                end: {
                                    line: node.location.end.line,
                                    column: node.location.end.column - 1,
                                },
                            },
                            range: [node.location.start.offset, node.location.end.offset],
                            raw: text.slice(node.location.start.offset, node.location.end.offset),
                            type: ast_node_types_1.ASTNodeTypes.Header,
                            children: node.args
                                .map(transform(text))
                                .reduce((a, b) => [...a, ...b], []),
                        },
                    ];
                default:
                    return [];
            }
        case "command.text":
            return [
                {
                    loc: {
                        start: {
                            line: node.location.start.line,
                            column: node.location.start.column - 1,
                        },
                        end: {
                            line: node.location.end.line,
                            column: node.location.end.column - 1,
                        },
                    },
                    range: [node.location.start.offset, node.location.end.offset],
                    raw: text.slice(node.location.start.offset, node.location.end.offset),
                    type: ast_node_types_1.ASTNodeTypes.Str,
                    children: transform(text)(node.arg),
                },
            ];
        case "env":
            switch (node.name) {
                case "itemize":
                case "enumerate":
                case "description":
                    return [...node.args, ...node.content]
                        .map(transformListItems(text))
                        .reduce((a, b) => [...a, ...b], []);
                default:
                    return [...node.args, ...node.content]
                        .map(transform(text))
                        .reduce((a, b) => [...a, ...b], []);
            }
        case "env.lstlisting":
        case "env.verbatim":
        case "env.minted":
            return [
                {
                    loc: {
                        start: {
                            line: node.location.start.line,
                            column: node.location.start.column - 1,
                        },
                        end: {
                            line: node.location.end.line,
                            column: node.location.end.column - 1,
                        },
                    },
                    range: [node.location.start.offset, node.location.end.offset],
                    raw: text.slice(node.location.start.offset, node.location.end.offset),
                    type: ast_node_types_1.ASTNodeTypes.CodeBlock,
                    value: node.content,
                },
            ];
        case "env.math.align":
        case "env.math.aligned":
        case "displayMath":
            return [
                {
                    loc: {
                        start: {
                            line: node.location.start.line,
                            column: node.location.start.column - 1,
                        },
                        end: {
                            line: node.location.end.line,
                            column: node.location.end.column - 1,
                        },
                    },
                    range: [node.location.start.offset, node.location.end.offset],
                    raw: text.slice(node.location.start.offset, node.location.end.offset),
                    value: text.slice(node.location.start.offset, node.location.end.offset),
                    type: ast_node_types_1.ASTNodeTypes.CodeBlock,
                },
            ];
        case "superscript":
        case "subscript":
            return [
                {
                    loc: {
                        start: {
                            line: node.location.start.line,
                            column: node.location.start.column - 1,
                        },
                        end: {
                            line: node.location.end.line,
                            column: node.location.end.column - 1,
                        },
                    },
                    range: [node.location.start.offset, node.location.end.offset],
                    raw: text.slice(node.location.start.offset, node.location.end.offset),
                    type: ast_node_types_1.ASTNodeTypes.Code,
                    children: node.arg === undefined ? [] : transform(text)(node.arg),
                },
            ];
        case "inlineMath":
        case "math.math_delimiters":
        case "math.matching_delimiters":
            return [
                {
                    loc: {
                        start: {
                            line: node.location.start.line,
                            column: node.location.start.column - 1,
                        },
                        end: {
                            line: node.location.end.line,
                            column: node.location.end.column - 1,
                        },
                    },
                    range: [node.location.start.offset, node.location.end.offset],
                    raw: text.slice(node.location.start.offset, node.location.end.offset),
                    value: text.slice(node.location.start.offset, node.location.end.offset),
                    type: ast_node_types_1.ASTNodeTypes.Code,
                },
            ];
        case "verb":
            return [
                {
                    loc: {
                        start: {
                            line: node.location.start.line,
                            column: node.location.start.column - 1,
                        },
                        end: {
                            line: node.location.end.line,
                            column: node.location.end.column - 1,
                        },
                    },
                    range: [node.location.start.offset, node.location.end.offset],
                    raw: text.slice(node.location.start.offset, node.location.end.offset),
                    type: ast_node_types_1.ASTNodeTypes.Code,
                    value: node.content,
                },
            ];
        case "text.string":
            return [
                {
                    loc: {
                        start: {
                            line: node.location.start.line,
                            column: node.location.start.column - 1,
                        },
                        end: {
                            line: node.location.end.line,
                            column: node.location.end.column - 1,
                        },
                    },
                    range: [node.location.start.offset, node.location.end.offset],
                    raw: text.slice(node.location.start.offset, node.location.end.offset),
                    type: ast_node_types_1.ASTNodeTypes.Str,
                    value: node.content,
                },
            ];
        case "arg.group":
            return node.content
                .map(transform(text))
                .reduce((a, b) => [...a, ...b], []);
        case "arg.optional":
            return node.content
                .map(transform(text))
                .reduce((a, b) => [...a, ...b], []);
        case "parbreak":
            return [
                {
                    loc: {
                        start: {
                            line: node.location.start.line,
                            column: node.location.start.column - 1,
                        },
                        end: {
                            line: node.location.end.line,
                            column: node.location.end.column - 1,
                        },
                    },
                    range: [node.location.start.offset, node.location.end.offset],
                    raw: text.slice(node.location.start.offset, node.location.end.offset),
                    type: "parbreak",
                },
            ];
        case "command.url":
            return [
                {
                    loc: {
                        start: {
                            line: node.location.start.line,
                            column: node.location.start.column - 1,
                        },
                        end: {
                            line: node.location.end.line,
                            column: node.location.end.column - 1,
                        },
                    },
                    range: [node.location.start.offset, node.location.end.offset],
                    raw: text.slice(node.location.start.offset, node.location.end.offset),
                    url: node.url,
                    type: ast_node_types_1.ASTNodeTypes.Link,
                    children: [
                        {
                            loc: {
                                start: {
                                    line: node.location.start.line,
                                    column: node.location.start.column - 1,
                                },
                                end: {
                                    line: node.location.end.line,
                                    column: node.location.end.column - 1,
                                },
                            },
                            range: [node.location.start.offset, node.location.end.offset],
                            raw: text.slice(node.location.start.offset, node.location.end.offset),
                            value: node.url,
                            type: ast_node_types_1.ASTNodeTypes.Str,
                        },
                    ],
                },
            ];
        case "command.href":
            return [
                {
                    loc: {
                        start: {
                            line: node.location.start.line,
                            column: node.location.start.column - 1,
                        },
                        end: {
                            line: node.location.end.line,
                            column: node.location.end.column - 1,
                        },
                    },
                    range: [node.location.start.offset, node.location.end.offset],
                    raw: text.slice(node.location.start.offset, node.location.end.offset),
                    url: node.url,
                    type: ast_node_types_1.ASTNodeTypes.Link,
                    children: node.content
                        .map(transform(text))
                        .reduce((a, b) => [...a, ...b], []),
                },
            ];
        case "command.label":
            return [
                {
                    loc: {
                        start: {
                            line: node.location.start.line,
                            column: node.location.start.column - 1,
                        },
                        end: {
                            line: node.location.end.line,
                            column: node.location.end.column - 1,
                        },
                    },
                    range: [node.location.start.offset, node.location.end.offset],
                    raw: text.slice(node.location.start.offset, node.location.end.offset),
                    value: node.label,
                    type: ast_node_types_1.ASTNodeTypes.Html,
                },
            ];
        case "ignore":
        case "alignmentTab":
        case "activeCharacter":
        case "math.character":
        case "command.def":
        case "commandParameter":
            return [];
        default:
            return [];
    }
};
const transformListItems = (text) => (node) => {
    if (node.kind === "math.character" || node.kind === "parbreak") {
        return [];
    }
    const isItemCommand = node.kind === "command" && node.name === "item";
    const nodeType = isItemCommand ? ast_node_types_1.ASTNodeTypes.Html : ast_node_types_1.ASTNodeTypes.ListItem;
    return [
        {
            loc: {
                start: {
                    line: node.location.start.line,
                    column: node.location.start.column - 1,
                },
                end: {
                    line: node.location.end.line,
                    column: node.location.end.column - 1,
                },
            },
            range: [node.location.start.offset, node.location.end.offset],
            raw: text.slice(node.location.start.offset, node.location.end.offset),
            type: nodeType,
            children: transform(text)(node),
        },
    ];
};
const parse = (text) => {
    const parserOpt = {
        startRule: "Root",
        enableComment: true,
        tracer: undefined,
        // TODO: Add timeout option
        timeout: undefined,
    };
    const latexAst = normalize(latex_utensils_1.latexParser.parse(text, parserOpt));
    const comments = latexAst.comment ? latexAst.comment : [];
    // TODO: Refactoring
    return pipeable_1.pipe({
        type: ast_node_types_1.ASTNodeTypes.Document,
        raw: text,
        range: function_1.tuple(0, text.length),
        loc: {
            start: calculatePosition_1.default(text, 0),
            end: calculatePosition_1.default(text, text.length - 1),
        },
        children: latexAst.content
            .map(transform(text))
            .reduce((a, b) => [...a, ...b], []),
    }, paragraphize_1.default, completeComment_1.completeComments(comments)(text), completeBlank_1.default(text));
};
exports.parse = parse;
