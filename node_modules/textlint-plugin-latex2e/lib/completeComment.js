"use strict";
/*
 * Copyright (c) 2020 Textlint Plugin LaTex2e team. All rights reserved.
 *
 * This file is part of textlint-plugin-latex2e.
 * This software is released under the MIT License, see LICENSE.md .
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.completeComments = exports.insertComment = exports.isParentNode = exports.isIncludedByNode = exports.isAppearedBeforeNode = exports.convertCommentToTxtNode = void 0;
const ast_node_types_1 = require("@textlint/ast-node-types");
const convertCommentToTxtNode = (rawText, comments) => {
    if (!comments) {
        return [];
    }
    return comments === null || comments === void 0 ? void 0 : comments.map((comment) => {
        return {
            loc: {
                start: {
                    line: comment.location.start.line,
                    column: comment.location.start.column - 1,
                },
                end: {
                    line: comment.location.end.line,
                    column: comment.location.end.column - 1,
                },
            },
            range: [comment.location.start.offset, comment.location.end.offset],
            raw: rawText.slice(comment.location.start.offset, comment.location.end.offset),
            value: comment.content,
            type: ast_node_types_1.ASTNodeTypes.Comment,
        };
    });
};
exports.convertCommentToTxtNode = convertCommentToTxtNode;
const isAppearedBeforeNode = (nodeRange, commentRange) => {
    return nodeRange[0] >= commentRange[1];
};
exports.isAppearedBeforeNode = isAppearedBeforeNode;
const isIncludedByNode = (nodeRange, commentRange) => {
    return nodeRange[0] <= commentRange[0] && nodeRange[1] >= commentRange[1];
};
exports.isIncludedByNode = isIncludedByNode;
const isParentNode = (node) => {
    const children = node.children;
    return (typeof node === "object" &&
        children !== undefined &&
        Array.isArray(children));
};
exports.isParentNode = isParentNode;
const insertComment = (comment, nodes) => {
    if (!nodes) {
        return exports.insertComment(comment, []);
    }
    for (let i = 0; i < nodes.length; i++) {
        // If the comment is appeared before the node, insert it before the node.
        if (exports.isAppearedBeforeNode(nodes[i].range, comment.range)) {
            nodes.splice(i, 0, comment);
            return nodes;
        }
        // If the comment is included in the node, try to insert it recursively.
        if (exports.isIncludedByNode(nodes[i].range, comment.range)) {
            if (exports.isParentNode(nodes[i])) {
                nodes[i].children = exports.insertComment(comment, nodes[i].children);
                return nodes;
            }
            switch (nodes[i].type) {
                case ast_node_types_1.ASTNodeTypes.Code:
                case ast_node_types_1.ASTNodeTypes.CodeBlock:
                    // Ignore comments in CodeBlock.
                    // This behavior is as same as the reference plugin(Markdown).
                    return nodes;
                default:
                    // `Parbreak` has no children, even though the range of
                    // `Parbreak` includes the range of comment
                    // if comment is surrounding by the line break.
                    // But the parbreak becomes null, so this condition does not used.
                    throw Error("Unexpected node is given. Is the syntax correct?");
            }
        }
    }
    // If the comment is not inserted, it would be appeared after all nodes.
    nodes.push(comment);
    return nodes;
};
exports.insertComment = insertComment;
// Mapping all comments to the given AST.
const completeComments = (comments) => (rawText) => (root) => {
    if (comments.length === 0) {
        return root;
    }
    const textlintComments = exports.convertCommentToTxtNode(rawText, comments);
    const copiedRoot = JSON.parse(JSON.stringify(root));
    for (const comment of textlintComments) {
        copiedRoot.children = exports.insertComment(comment, copiedRoot.children);
    }
    return copiedRoot;
};
exports.completeComments = completeComments;
